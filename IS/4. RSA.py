def gcd(a, b): # calculates GCD of a and d
    while b != 0:
        c = a % b
        a = b
        b = c
    return a

def modinv(a, m): # calculates modulo inverse of a for mod m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

def coprimes(a): # calculates all possible co-prime numbers with a
    l = []
    for x in range(2, a):
        if gcd(a, x) == 1 and modinv(x, phi) != None:
            l.append(x)
    for x in l:
        if x == modinv(x, phi):
            l.remove(x)
    return l

def encrypt_block(m): # encrypts a single block
    c = m ** e % n
    return c

def decrypt_block(c): # decrypts a single block
    m = c ** d % n
    return m

def encrypt_string(s): # applies encryption
    return ''.join([chr(encrypt_block(ord(x))) for x in list(s)])

def decrypt_string(s): # applies decryption
    return ''.join([chr(decrypt_block(ord(x))) for x in list(s)])

if __name__ == "__main__":
    p = int(input('Enter prime p: '))
    q = int(input('Enter prime q: '))
    print("Choosen primes:\np=" + str(p) + ", q=" + str(q) + "\n")
    n = p * q
    print("n = p * q = " + str(n) + "\n")
    phi = (p - 1) * (q - 1)
    print("Euler's function (totient) [phi(n)]: " + str(phi) + "\n")
    print("Choose an e from a below coprimes array:\n")
    print(str(coprimes(phi)) + "\n")
    e = int(input())
    d = modinv(e, phi) # calculates the decryption key d
    print("\nYour public key is a pair of numbers (e=" + str(e) + ", n=" + str(n) + ").\n")
    print("Your private key is a pair of numbers (d=" + str(d) + ", n=" + str(n)+ ").\n")
    s = input("Enter a message to encrypt: ")
    print("\nPlain message: " + s + "\n")
    enc = encrypt_string(s)
    print("Encrypted message: ", enc, "\n")
    dec = decrypt_string(enc)
    print("Decrypted message: " + dec + "\n")




# The code defines several functions: gcd, modinv, coprimes, encrypt_block, decrypt_block, encrypt_string, and decrypt_string. These functions perform various operations involved in the RSA encryption and decryption process.

# The gcd function calculates the greatest common divisor (GCD) of two numbers, a and b, using the Euclidean algorithm.

# The modinv function calculates the modular inverse of a modulo m. It finds a value x such that (a * x) % m = 1.

# The coprimes function generates a list of all possible co-prime numbers with a. It iterates over a range of numbers from 2 to a-1 and checks if each number is coprime with a using the gcd function. Additionally, it verifies if the modular inverse of the number with respect to phi is not None. If these conditions are satisfied, the number is added to the list of coprimes.

# The encrypt_block function encrypts a single block of plaintext m. It applies the RSA encryption formula: c = (m ** e) % n, where e is the encryption key and n is the product of two prime numbers p and q.

# The decrypt_block function decrypts a single block of ciphertext c. It applies the RSA decryption formula: m = (c ** d) % n, where d is the decryption key and n is the product of the two prime numbers p and q.

# The encrypt_string function applies the RSA encryption algorithm to encrypt a string s. It converts each character of the string to its corresponding ASCII value, encrypts the ASCII value using encrypt_block, and then converts the resulting ciphertext back to characters.

# The decrypt_string function applies the RSA decryption algorithm to decrypt a ciphertext string s. It converts each character of the string to its corresponding ASCII value, decrypts the ASCII value using decrypt_block, and then converts the resulting plaintext back to characters.

# The main execution starts with the if __name__ == "__main__": condition, which ensures that the code is only executed if the script is run directly (not imported as a module).

# The user is prompted to enter two prime numbers p and q. These primes are used to calculate the modulus n.

# The modulus n is calculated as the product of p and q.

# The Euler's totient function (phi) is calculated as (p-1) * (q-1). It represents the number of positive integers less than n that are coprime to n.

# The user is presented with a list of coprime numbers generated by the coprimes function, and they are asked to choose an encryption key e from the list.

# The decryption key d is calculated by calling the modinv function with arguments e and phi.

# The public and private keys are printed to the console.

# The user is prompted to enter a message to encrypt.

# The input message is encrypted using the encrypt_string function.

# The encrypted message is printed to the console.

# The encrypted message is decrypted using the decrypt_string function.

# The decrypted message is printed to the console.